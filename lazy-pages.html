<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../neon-animation/neon-animation-runner-behavior.html">
<link rel="import" href="../neon-animation/animations/opaque-animation.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<!--
lazy-pages

load the pages right away,
or load them lazy.

@demo
-->

<dom-module id="lazy-pages">
  <template>
    <style>

      :host {
        display: block;
        position: relative;
      }

      :host > ::content > * {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        height: 100%;
      }

      :host > ::content > :not(.iron-selected):not(.neon-animating) {
        display: none !important;
      }

      :host > ::content > .neon-animating {
        pointer-events: none;
      }

    </style>
    <content id="content"></content>
  </template>
</dom-module>

<script>

(function() {

/**
 * Helper class for 'lazy-pages'
 * Animation transition state machine
 * Cancel by calling stop
 */
var LazyTransition = function(lazy) {
  this.lazy = lazy;
  this._boundDomChange = this.handleDomChange.bind(this);
};

LazyTransition.prototype = {

  /**
   * @param {Node} entryPage -- node we are transitioning to
   * @param {Node} exitPage -- node we are leaving
   */
  start: function(entryPage, exitPage) {
    this.entryPage = this.entryInstance = entryPage;
    this.exitPage = this.exitInstance = exitPage;
    if (this.isTemplate(this.exitPage)) {
      this.exitInstance = this.lazy._getInstanceElement(this.exitPage);
    };

    // add class to exitInstance to prevent display:none)
    if (this.exitInstance) {
      Polymer.dom(this.exitInstance).classList.add('neon-animating');
      Polymer.dom(this.exitInstance).classList.remove('iron-selected');
    }

    // start entryPage activation
    this.lazy._currentPage = this.entryPage;
    if (this.isTemplate(this.entryPage)) {
      this.entryPage.addEventListener('dom-change', this._boundDomChange);
      if (this.entryPage.if)
        console.warn('transitioning to already showing template');
      this.entryPage.if = true; // generate the dom
    }
    else {
      this.entryInstance = this.lazy._getInstanceElement(this.entryPage);
      this.startAnimation();
    }

  },

  /**
   * Aborts transition
   */
  stop: function() {
    this.cleanup();
  },

  handleDomChange: function(ev) {
    if (this.done)
      return;
    this.entryPage.removeEventListener('dom-change', this._boundDomChange);
    this.entryInstance = this.lazy._getInstanceElement(this.entryPage);
    if (!this.entryInstance) {
      console.error('template missing an instance', this.entryPage);
    }
    this.startAnimation();
  },

  startAnimation: function() {
    if (this.done)
      return;

    // make entry page visible
    if (this.entryInstance)
      this.entryInstance.classList.add('iron-selected');

    var animations = this.lazy._getAnimations(this.entryPage, this.exitPage);
    var config = [];
    if (animations.entry) {
      config.push({
        name: 'opaque-animation',
        node: this.entryInstance
      });
      config.push( animations.entry);
    }
    if (animations.exit)
      config.push( animations.exit);

    if (config.length > 0) {
      this.lazy.animationConfig = config;
      this._boundAnimationFinish = this.animationFinish.bind(this);
      this.lazy.addEventListener('neon-animation-finish', this._boundAnimationFinish);
      this.lazy.playAnimation(null, this);
    }
    else {
      this.cleanup();
    }
  },

  animationFinish: function(ev) {
    // console.log('animation finish');
    if (ev.detail != this) // ignore animations that have not been started by us
      return;
    this.cleanup();
  },

  cleanup: function() {
    this.done = true;

    if (this._boundAnimationFinish) {
      this.lazy.removeEventListener('neon-animation-finish', this._boundAnimationFinish);
      delete this._boundAnimationFinish;
    }
    if (this.exitInstance) {
      if (this.isTemplate(this.exitPage))
        this.exitPage.if = false;
      Polymer.dom(this.exitInstance).classList.remove('neon-animating');
    }
    if (this.lazy._lazyTransition === this)
      this.lazy._lazyTransition = null;
  },

  isTemplate: function(node) {
    return node && node.nodeName === 'TEMPLATE';
  }

};

'use strict';

Polymer({

  is: 'lazy-pages',

  behaviors: [
    Polymer.NeonAnimationRunnerBehavior,
    Polymer.IronResizableBehavior
  ],

  properties: {

    /**
     * value of currentlySelectedItem[attr_for_selected],
     * or index if attr_for_selected is undefined
     */
    selected: {
      type: String,
      notify: true,
      observer: '_selectedChanged'
    },

    attrForSelected: {
      type: String,
      value: null
    },

    /**
     * Animate first page load if true
     */
    animateInitialSelection: {
      type: Boolean,
      value: false
    },

    /**
     * Use it to specify transition animations dynamically
     *
     * @type Function(entryPage, exitPage, entryInstance, exitInstance)
     */
     animationOracle: {
      type: Function
     }
  },

  observers: [
     '_updateSelection(selected, attrForSelected)'
  ],

  /**
   * Currently selected page
   */
  get selectedPage() {
    return this._currentPage;
  },

  _selectedChanged: function(selected) {
    // Select a new page when selected changes
    if (selected != null) {
      var newPage = this._findPageBySelected(selected);
      if (newPage) {
        this._selectPage(newPage);
      }
      else {
        console.warn('selected not found', selected);
        this.selected = this._findCurrentSelected();
      }
    }
  },

  _updateSelection: function(selected, attrForSelected) {
    this._selectedChanged(selected);
  },

  /**
   * @return an array of selectable nodes
   */
  _getSelectableNodes: function() {
    var nodes = Polymer.dom(this.$.content).getDistributedNodes();
    // filter out all the element nodes
    var selectableNodes = [];
    var instances = new WeakMap();

    // find all the element nodes
    for (var i=0; i<nodes.length; i++) {
      if (nodes[i].nodeType === 1) {
        var el = nodes[i];
        // keep track of template instances
        if (el.nodeName === 'TEMPLATE') {
          if (el._instance) {
            instances.set(this._getInstanceElement(el), true);
          }
        }
        selectableNodes.push(el);
      }
    }
    // remove all template instances, we do not consider those selectable
    for (var i=selectableNodes.length -1; i>=0; i--) {
      if (instances.has(selectableNodes[i])) {
        selectableNodes.splice(i--, 1);
      }
    }
    return selectableNodes;
  },

  _findPageBySelected: function(selected) {
    var selectables = this._getSelectableNodes();

    if (!this.attrForSelected) {
      return selectables[selected];
    }
    else {
      for (var i=0; i<selectables.length; i++) {
        if (selectables[i].getAttribute(this.attrForSelected) == 'selected')
          return selectables[i];
      }
    }
    return null;
  },

  _findCurrentSelected: function() {
    var selectables = this._getSelectableNodes();
    for (var i=0; i<selectables.length; i++) {
      if (selectables[i].classList.contains('iron-selected'))
        return selectables[i];
    }
    return null;
  },

  /**
   * animation names must be defined in animationConfig
   * @return {entry: animationConfig, exit: animationConfig}
   */
  _getAnimations: function(entryPage, exitPage ) {

    if (!exitPage && !this.animateInitialSelection) {
      return {};
    }
    var entryInstance = entryPage ? this._getInstanceElement(entryPage) : null;
    var exitInstance = exitPage ? this._getInstanceElement(exitPage) : null;
    var animation;

    if (this.animationOracle) {
      animation = this.animationOracle(entryPage, exitPage, entryInstance, exitInstance);
      if (animation)
        return animation;
    }

    animation = {};

    if (entryInstance) {
      if (this.entryAnimation) {
        animation.entry = {
          name: this.entryAnimation,
          node: entryInstance
        };
      }
      else {
        if (entryInstance.getAnimationConfig) {
          animation.entry = {
            animatable: entryInstance,
            type: 'entry'
          }
        }
      }
    }

    if (exitInstance) {
      if (this.exitAnimation) {
        animation.exit = {
          name: this.exitAnimation,
          node: exitInstance
        }
      }
      else {
        if (exitInstance.getAnimationConfig) {
          animation.exit = {
            animatable: this.exitInstance,
            type: 'exit'
          }
        }
      }
    }

    return animation;
  },

  _selectPage: function(page) {
    if (page === this._currentPage)
      return;

    if (this._lazyTransition) {
      console.log('canceling transition');
      this._lazyTransition.stop();
    }
    this._lazyTransition = new LazyTransition(this);
    this._lazyTransition.start(page, this._currentPage);
  },

  /**
   * @param {Node} template -- dom-if template.
   * @return {Node} instance belonging to template
   */
  _getInstanceElement: function(template) {
    if (!template) {
      console.warn('template is null', template);
      return null;
    }

    if (template.nodeName !== 'TEMPLATE') // this is not a template, so it is also an instance
      return template;

    if (!template._instance) {
      console.warn('template instance is null', template);
      return null;
    }
    var instance = template._instance;
    var el = null;
    for (var i=0; i<instance._children.length; i++) {
      if (instance._children[i].nodeType === 1) {
        if (el != null) {
          console.warn('dom-if children inside lazy-pages can only have a single element', template);
        } else {
          el = instance._children[i];
        }
      }
    }
    if (!el) {
      console.warn('template instance without element children', instance);
    }
    return el;
  },

});

})();
</script>
